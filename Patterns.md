<h2>SOLID:</h2>
* **Single responsibility** — принцип единственной ответственности (класс должен выполнять только 1 задачу, уменьшение связности)
* **Open-closed** — принцип открытости / закрытости (виртуальные методы, не if, а наследования)
* **Liskov substitution** — принцип подстановки Барбары Лисков (классы-наследники используются вместо родительских классов, от которых они образованы, не нарушая работу программы)
* **Interface segregation** — принцип разделения интерфейса (интерфейс должен решать лишь какую-то одну задачу и не содержать лишнего)
* **Dependency inversion** — принцип инверсии зависимостей (Модули верхних уровней не должны зависеть от модулей нижних уровней)

<h2>ООП:</h2>
* **Абстракция** — отделение концепции от ее экземпляра;
* **Полиморфизм** — реализация задач одной и той же идеи разными способами;
* **Наследование** — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
* **Инкапсуляция** — размещение одного объекта или класса внутри другого для разграничения доступа к ним.

<h2>DRY:</h2>
dont repeate yourself

<h2>KISS:</h2>
keep it simple, stupid (keep it short and simple)

<h2>Redux (Flux):</h2>
Реализует архитектурный паттерн Flux, основные концепции
* **Store** – хранилище для состояния приложения,
* **Actions** – объекты действий, описывающих что произошло в системе,
* **Reducers** – функции преобразования событий в состояние.

Библиотека использует паттерны функционального программирования – состояние декларируется как неизменяемое (Immutable), а reducers должны быть описаны как чистые (pure) функции. При таком подходе упрощается тестирование и отладка программы. 

<h2>MVC:</h2>

<h2>MVVM:</h2>

<h2>Rx:</h2>
Паттерн наблюдатель.
