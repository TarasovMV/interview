<h2>Сложность алгоритма</h2>
O(n) и др... Смотрим по худшему случаю

<h2>Поиск элемента в массиве</h2>
* **Линейный поиск** - сложность O(n)
* **Бинарный поиск** - сложность O(log2n) - должен быть отсортирован

<h2>Сортировка</h2>
* **Выбором** - сложность O(n*n)
* **Пузырьковая сортировка** - сложность O(n*n) - меняем парные элементы во вложенном цикле
* **Быстрая сортировка** - сложность O(log2n*n) - реализуется рекурсивно, выбираем элемент в массиве (обычно по середине) сравниваем все элементы м ним разделяя массив на больше и меньше, условие выхода - длина массива <= 1

<h2>Графы</h2>
* **Матрица смежности** - двумерная квадратная матрица, если путь есть, то 1, если нет то 0 на пересечении
* **Поиск в ширину** - реализуется через FIFO - на каждом шаге убираем первый элемент массива и смотрим нет ли у этого узла конечной точки, если есть возвращаем true, если нет, то добавляем в конец массива узлы соединенные с удаленным узлом
* **Алгоритм Дейкстры** - поиск кратчайших путей от выбранного узла до каждого, есть веса

<h2>Дерево</h2>
* Это рекурсивная структура
* Бинарное дерево - у каждого узла только 2 потомка, если добавляемое в дерево значение < чем текущий угол, то уходит влево, в обратном случае вправо
